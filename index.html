<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Captura de Ojo con YOLO</title>
  <style>
    :root{--bg:#0f172a;--card:#111827;--muted:#94a3b8;--accent:#22c55e;--danger:#ef4444;--ring:#38bdf8}
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;background:linear-gradient(180deg,#0b1220,#0f172a);}
    header{padding:18px 16px;color:white;display:flex;gap:12px;align-items:center;justify-content:center;border-bottom:1px solid #1f2937;position:sticky;top:0;background:#0b1220aa;backdrop-filter:blur(6px)}
    main{max-width:980px;margin:20px auto;padding:16px}
    .card{background:rgba(17,24,39,0.9);border:1px solid #1f2937;border-radius:16px;overflow:hidden;color:#e5e7eb;box-shadow:0 10px 30px rgba(0,0,0,.4)}
    .section{padding:16px;border-top:1px dashed #1f2937}
    .section:first-child{border-top:none}
    .grid{display:grid;gap:16px}
    @media(min-width:900px){.grid{grid-template-columns:1.2fr .8fr}}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label{font-weight:600}
    input[type="text"]{width:260px;padding:10px;border-radius:10px;border:1px solid #334155;background:#0b1220;color:#e5e7eb;outline:none}
    input[type="checkbox"]{transform:scale(1.2)}
    button{padding:12px 16px;border-radius:12px;border:1px solid #1f2937;background:#0b1220;color:#e5e7eb;cursor:pointer}
    button.primary{background:linear-gradient(180deg,#16a34a,#16a34a 60%,#15803d);border-color:#14532d}
    button.secondary{background:#0b1220}
    button:disabled{opacity:.5;cursor:not-allowed}
    .video-wrap{position:relative;border-radius:16px;overflow:hidden;border:1px solid #1f2937}
    video,canvas{display:block;width:100%;height:auto}
    canvas.overlay{position:absolute;inset:0;pointer-events:none}
    .pill{display:inline-flex;align-items:center;gap:8px;background:#0b1220;border:1px solid #1f2937;padding:8px 12px;border-radius:999px;color:#cbd5e1}
    .muted{color:#94a3b8}
    .ok{color:#22c55e}
    .err{color:#ef4444}
    .thumb{width:100%;border-radius:12px;border:1px solid #1f2937}
    .small{font-size:.9rem}
    .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;background:#111827;border:1px solid #1f2937;border-bottom-width:3px;padding:2px 6px;border-radius:6px}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}
    .badge{font-size:.75rem;padding:2px 8px;border-radius:999px;border:1px solid #1f2937;background:#0b1220;color:#93c5fd}
  </style>
  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
  <header>
    <span class="pill"><strong>YOLO Eye Capture</strong> <span class="badge">Client-side</span></span>
  </header>
  <main>
    <div class="card">
      <div class="section grid">
        <div>
          <h2>Consentimiento e Identificación</h2>
          <p class="muted small">Para continuar, acepta el tratamiento de tu imagen y escribe tu nombre.</p>
          <div class="row" style="margin-top:8px">
            <input id="name" type="text" placeholder="Nombre del participante" />
            <label class="row" style="gap:8px"><input id="consent" type="checkbox" /> Acepto el uso de mi imagen para análisis.</label>
          </div>
          <p id="consentStatus" class="muted small" style="margin-top:8px">Estado: <span id="consentIcon">❌</span> Falta consentimiento/nombre</p>
        </div>
        <div>
          <h3>Instrucciones</h3>
          <ol class="small" style="line-height:1.7">
            <li>Position yourself in front of the camera.</li>
            <li>Focus your eye on the camera.</li>
            <li>Keep a distance of about 10–15 cm from the camera.</li>
            <li>Open your eye wide.</li>
            <li>Make sure the image is clear and sharp.</li>
            <li>Press the button below to capture the photo.</li>
          </ol>
        </div>
      </div>

      <div class="section">
        <div class="row" style="justify-content:space-between">
          <div class="row">
            <button id="start" class="primary">Activar cámara</button>
            <button id="flip" class="secondary" title="Cambiar cámara" disabled>Cambiar cámara</button>
          </div>
          <div class="row small">
            <span id="modelStatus" class="muted">Modelo: no cargado</span>
            <span id="fps" class="muted">•</span>
          </div>
        </div>
        <div class="video-wrap" style="margin-top:12px">
          <video id="video" playsinline muted></video>
          <canvas id="overlay" class="overlay"></canvas>
        </div>
        <div class="row" style="margin-top:12px;justify-content:space-between">
          <div class="row small"><span class="muted">Cámara:</span> <span id="camLabel" class="kbd">—</span></div>
          <div class="row"><button id="capture" class="primary" disabled>Capturar ojo</button></div>
        </div>
      </div>

      <div class="section grid">
        <div><h3>Resultado</h3><img id="thumb" class="thumb" alt="Recorte del ojo" /></div>
        <div><h3>Subida</h3><p class="small muted">El recorte del ojo se enviará automáticamente al almacenamiento.</p><div class="mono small" id="uploadLog">Listo.</div></div>
      </div>

      <div class="section small muted">
        <p><strong>Privacidad:</strong> El procesamiento del detector se realiza en tu navegador. Solo se sube el recorte final del ojo cuando presionas «Capturar ojo».</p>
      </div>
    </div>
  </main>

<script>
// ===================== CONFIG ===================== //
const MODEL_URL = "https://huggingface.co/pedro123gtz/yolo-eye-model/resolve/main/best.onnx";
const MODEL_INPUT_SIZE = 320;          // detección rápida (no afecta la calidad de la foto final)
const MODEL_CONF_THRESHOLD = 0.35;
const MODEL_IOU_THRESHOLD  = 0.45;
const MODEL_CLASSES = ["eye"];

const DRIVE_WEBAPP_URL = "https://script.google.com/macros/s/AKfycbxXx18hiOBFQR_eEsxVxp5ye6K84Nt1M0wVGJ1ObTagKt0tkGj5vFPEbsKggOybhbEZ/exec";
const DRIVE_SECRET = "456";               // si usas token, pon el mismo en EXPECTED del Apps Script
const DRIVE_FOLDER = "Eyes_data";
const DRIVE_FOLDER_ID = "1xIspp2gSZ5tZKYQJ7VsVTdh2rTg2ohD4"; // tu carpeta destino por ID

// ===================== API estilo face-api.js ===================== //
window.eyeapi = (function(){
  const api = {};
  api.nets = {
    eyeDetector: {
      session: null,
      async loadFromUrl(url, providers=['webgpu','wasm']){
        for(const ep of providers){
          try{
            this.session = await ort.InferenceSession.create(url, { executionProviders:[ep] });
            return { provider: ep };
          }catch(e){}
        }
        throw new Error('No se pudo cargar el modelo en ningún EP');
      }
    }
  };
  class EyeDetectorOptions{
    constructor({ inputSize=MODEL_INPUT_SIZE, confThreshold=MODEL_CONF_THRESHOLD, iouThreshold=MODEL_IOU_THRESHOLD }={}){
      this.inputSize = inputSize; this.confThreshold = confThreshold; this.iouThreshold = iouThreshold;
    }
  }
  api.EyeDetectorOptions = EyeDetectorOptions;

  function postprocess(output, meta, confTh, iouTh){
    let data = output.data; let numBoxes, numAttrs;
    if(output.dims.length===3){
      const [n,a,b]=output.dims; numBoxes=b; numAttrs=a;
      const trans=new Float32Array(numBoxes*numAttrs);
      for(let i=0;i<a;i++) for(let j=0;j<b;j++) trans[j*numAttrs+i]=data[i*b+j];
      data=trans;
    } else if(output.dims.length===2){ numBoxes=output.dims[0]; numAttrs=output.dims[1]; }
    else return [];
    const boxes=[], scores=[], classes=[];
    const sig=(x)=>1/(1+Math.exp(-x));
    for(let i=0;i<numBoxes;i++){
      const off=i*numAttrs; const x=data[off],y=data[off+1],w=data[off+2],h=data[off+3];
      const obj=sig(data[off+4]); let cls=1, cid=0;
      if(numAttrs>5){ let best=0, bid=0; for(let c=5;c<numAttrs;c++){ const sc=sig(data[off+c]); if(sc>best){best=sc; bid=c-5;} } cls=best; cid=bid; }
      const conf=obj*cls; if(conf<confTh) continue;
      const x1=x-w/2, y1=y-h/2, x2=x+w/2, y2=y+h/2;
      boxes.push([x1,y1,x2,y2]); scores.push(conf); classes.push(cid);
    }
    const keep=(function(b,s,iouT,maxDet=50){
      const ord=s.map((v,i)=>[v,i]).sort((A,B)=>B[0]-A[0]).map(x=>x[1]); const out=[];
      function iou(a,b){ const x1=Math.max(a[0],b[0]), y1=Math.max(a[1],b[1]), x2=Math.min(a[2],b[2]), y2=Math.min(a[3],b[3]);
        const w=Math.max(0,x2-x1), h=Math.max(0,y2-y1), inter=w*h, A=(a[2]-a[0])*(a[3]-a[1]), B=(b[2]-b[0])*(b[3]-b[1]);
        return inter/(A+B-inter+1e-6); }
      for(const i of ord){ let keep=true; for(const j of out){ if(iou(b[i],b[j])>iouT){ keep=false; break; } } if(keep){ out.push(i); if(out.length>=maxDet) break; } }
      return out;
    })(boxes, scores, iouTh);
    const res=[];
    for(const i of keep){
      const [x1,y1,x2,y2]=boxes[i]; const {ratio,dx,dy,iw,ih}=meta;
      const sx1=(x1-dx)/ratio, sy1=(y1-dy)/ratio, sx2=(x2-dx)/ratio, sy2=(y2-dy)/ratio;
      const X1=Math.max(0,Math.min(iw,sx1)), Y1=Math.max(0,Math.min(ih,sy1)), X2=Math.max(0,Math.min(iw,sx2)), Y2=Math.max(0,Math.min(ih,sy2));
      res.push({ box:[X1,Y1,X2,Y2], score:scores[i], label:(MODEL_CLASSES[classes[i]]||`c${classes[i]}`) });
    }
    return res;
  }

  api.detectAllEyes = async function(input, opts=new EyeDetectorOptions()){
    const sess = api.nets.eyeDetector.session; if(!sess) throw new Error('Modelo no cargado');
    const lb = letterbox(input, opts.inputSize);
    const px = lb.canvas.getContext('2d').getImageData(0,0,lb.canvas.width, lb.canvas.height).data;
    const size = opts.inputSize*opts.inputSize; const arr=new Float32Array(size*3);
    for(let i=0,p=0;i<size;i++,p+=4){ arr[i]=px[p]/255; arr[i+size]=px[p+1]/255; arr[i+2*size]=px[p+2]/255; }
    const inName = sess.inputNames[0];
    const t0 = performance.now();
    const out = await sess.run({ [inName]: new ort.Tensor('float32', arr, [1,3,opts.inputSize,opts.inputSize]) });
    const dt = performance.now()-t0; if(typeof fpsLabel!=='undefined'){ fpsLabel.textContent = `${(1000/dt).toFixed(1)} fps`; }
    return postprocess(out[sess.outputNames[0]], lb, opts.confThreshold, opts.iouThreshold);
  };

  api.detectSingleEye = async (input, opts)=>{ const a=await api.detectAllEyes(input, opts); return a.length?a[0]:null; };
  return api;
})();

// ===================== ESTADO & UTILS ===================== //
let streaming=false, currentStream=null, useFrontCamera=true, lastDetections=[];
let tick=0; const RUN_EVERY=3;

const $ = (s)=>document.querySelector(s);
const nameInput=$("#name"), consentInput=$("#consent"), consentIcon=$("#consentIcon"), consentStatus=$("#consentStatus");
const startBtn=$("#start"), flipBtn=$("#flip"), captureBtn=$("#capture");
const modelStatus=$("#modelStatus"), fpsLabel=$("#fps"), video=$("#video"), overlay=$("#overlay"), ctx=overlay.getContext("2d");
const camLabel=$("#camLabel"), thumb=$("#thumb"), uploadLog=$("#uploadLog");

const STABILITY={ confMin:0.55, minAreaRatio:0.005, ema:0.35, iouKeep:0.50, maxCoast:6, requireStableFrames:8 };
let track=null; // {box:[x1,y1,x2,y2], score, stable, coast}

function area(b){ const w=b[2]-b[0], h=b[3]-b[1]; return Math.max(0,w)*Math.max(0,h); }
function iouBox(a,b){ const x1=Math.max(a[0],b[0]), y1=Math.max(a[1],b[1]), x2=Math.min(a[2],b[2]), y2=Math.min(a[3],b[3]);
  const w=Math.max(0,x2-x1), h=Math.max(0,y2-y1), inter=w*h, A=(a[2]-a[0])*(a[3]-a[1]), B=(b[2]-b[0])*(b[3]-b[1]); return inter/(A+B-inter+1e-6); }
function emaBox(p,c,a){ return [p[0]*(1-a)+c[0]*a, p[1]*(1-a)+c[1]*a, p[2]*(1-a)+c[2]*a, p[3]*(1-a)+c[3]*a]; }
function chooseBest(dets){
  const W=overlay.width,H=overlay.height,minA=STABILITY.minAreaRatio*W*H;
  const norm=dets.map(d=>({...d, xyxy:d.xyxy||d.box}));
  const f=norm.filter(d=>d.score>=STABILITY.confMin && area(d.xyxy)>=minA);
  if(!f.length) return null; f.sort((a,b)=>b.score-a.score); return f[0];
}
function drawTrack(t){
  ctx.clearRect(0,0,overlay.width,overlay.height); if(!t) return;
  const [x1,y1,x2,y2]=t.box, w=x2-x1, h=y2-y1;
  ctx.lineWidth=3; ctx.strokeStyle='#22c55e'; ctx.fillStyle='rgba(34,197,94,.12)';
  ctx.beginPath(); ctx.rect(x1,y1,w,h); ctx.stroke(); ctx.fill();
  ctx.font='16px ui-monospace, monospace'; const tag=`eye ${(t.score*100).toFixed(0)}% · ${t.stable}f`;
  const tw=ctx.measureText(tag).width+10; ctx.fillStyle='#0b1220'; ctx.fillRect(x1,Math.max(0,y1-22),tw,22);
  ctx.fillStyle='#93c5fd'; ctx.fillText(tag,x1+5,Math.max(16,y1-6));
}
function updateCaptureState(){ captureBtn.disabled=!(track && track.stable>=STABILITY.requireStableFrames); }
function updateConsentState(){ const ok=!!nameInput.value.trim() && consentInput.checked; consentIcon.textContent=ok?'✅':'❌'; consentStatus.className=ok?'small ok':'small err'; startBtn.disabled=!ok; }
nameInput.addEventListener('input',updateConsentState); consentInput.addEventListener('change',updateConsentState); updateConsentState();

function sleep(ms){return new Promise(r=>setTimeout(r,ms));}
function letterbox(img,newSize){
  const iw=img.videoWidth||img.width, ih=img.videoHeight||img.height; const r=Math.min(newSize/iw,newSize/ih);
  const nw=Math.round(iw*r), nh=Math.round(ih*r), dx=Math.floor((newSize-nw)/2), dy=Math.floor((newSize-nh)/2);
  const c=document.createElement('canvas'); c.width=newSize; c.height=newSize; const t=c.getContext('2d');
  t.fillStyle='#000'; t.fillRect(0,0,newSize,newSize); t.drawImage(img,0,0,iw,ih,dx,dy,nw,nh);
  return {canvas:c, ratio:r, dx, dy, iw, ih};
}

// ===================== CÁMARA ===================== //
async function startCamera(){
  if(currentStream){ currentStream.getTracks().forEach(t=>t.stop()); }
  const facingMode = useFrontCamera ? 'user' : 'environment';
  try{
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode, width:{ideal:1280}, height:{ideal:720} }, // HD para buena captura
      audio: false
    });
    currentStream = stream;
    video.srcObject = stream;
    await video.play();
    overlay.width = video.videoWidth; overlay.height = video.videoHeight;
    camLabel.textContent = facingMode;
    flipBtn.disabled = false; captureBtn.disabled = false; streaming = true;
  }catch(err){ alert('No se pudo acceder a la cámara: '+err.message); }
}
flipBtn.addEventListener('click', async ()=>{ useFrontCamera=!useFrontCamera; await startCamera(); });
startBtn.addEventListener('click', async ()=>{
  await startCamera();
  await loadModel();
  detectLoop();
});

// ===================== MODELO ===================== //
async function loadModel(){
  modelStatus.textContent='Modelo: cargando…';
  try{
    const { provider } = await eyeapi.nets.eyeDetector.loadFromUrl(MODEL_URL, ['webgpu','wasm']);
    // warm-up
    const tmp=document.createElement('canvas'); tmp.width=MODEL_INPUT_SIZE; tmp.height=MODEL_INPUT_SIZE;
    const opts=new eyeapi.EyeDetectorOptions({ inputSize:MODEL_INPUT_SIZE, confThreshold:0.99 });
    await eyeapi.detectAllEyes(tmp, opts);
    modelStatus.textContent=`Modelo: listo (${provider})`;
  }catch(e){ console.error(e); modelStatus.textContent='Modelo: error al cargar'; }
}

// ===================== LOOP (rápido) ===================== //
async function detectLoop(){
  const opts=new eyeapi.EyeDetectorOptions({ inputSize:MODEL_INPUT_SIZE, confThreshold:MODEL_CONF_THRESHOLD, iouThreshold:MODEL_IOU_THRESHOLD });
  while(streaming){
    try{
      tick++;
      if(tick % RUN_EVERY !== 0){ drawTrack(track); updateCaptureState(); await sleep(10); continue; }
      lastDetections = await eyeapi.detectAllEyes(video, opts);
      const best = chooseBest(lastDetections);
      if(!track && best){ track={box:[...best.xyxy], score:best.score, stable:1, coast:0}; }
      else if(track){
        if(best){ const iou=iouBox(track.box,best.xyxy);
          if(iou>=STABILITY.iouKeep){ track.box=emaBox(track.box,best.xyxy,STABILITY.ema); track.score=best.score; track.stable=Math.min(track.stable+1,1e9); track.coast=0; }
          else track.coast++;
        } else track.coast++;
        if(track.coast>STABILITY.maxCoast) track=null;
      }
      drawTrack(track); updateCaptureState();
    }catch(e){ console.error(e); await sleep(100); }
    await sleep(10);
  }
}

async function pingWebApp(){
  try {
    const r = await fetch(DRIVE_WEBAPP_URL, { method: 'GET', cache: 'no-store' });
    const t = await r.text();
    console.log('PING', r.status, t);
    uploadLog.textContent = `Ping: ${r.status} · ${t.slice(0,80)}...`;
  } catch (e) {
    console.error('Ping failed', e);
    uploadLog.textContent = 'Ping falló: ' + e.message;
  }
}
// Llama pingWebApp() al cargar o antes de capturar


// ===================== CAPTURA + SUBIDA ===================== //
function cropToBlob(det){
  const [x1,y1,x2,y2]=det.xyxy.map(v=>Math.round(v));
  const w=Math.max(1,x2-x1), h=Math.max(1,y2-y1);
  const c=document.createElement('canvas'); c.width=w; c.height=h; c.getContext('2d').drawImage(video,x1,y1,w,h,0,0,w,h);
  return new Promise(res=> c.toBlob(b=>res(b),'image/jpeg',0.95));
}

// Subida con intento 1 (multipart) y fallback a intento 2 (JSON/base64)
async function uploadToDrive(blob){
  uploadLog.textContent = 'Subiendo…';
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  const fname = `${(nameInput.value.trim() || 'anon')}_${ts}.jpg`;

  // ---- Intento 1: multipart/form-data (Blob directo + filename) ----
  try{
    const form = new FormData();
    form.append('file', blob, fname);              // Blob + filename
    form.append('name', nameInput.value.trim() || 'anon');
    form.append('folder', DRIVE_FOLDER);
    form.append('folderId', DRIVE_FOLDER_ID);
    form.append('secret', DRIVE_SECRET);

    const resp = await fetch(DRIVE_WEBAPP_URL, { method:'POST', body: form });
    const text = await resp.text();
    let json; try { json = JSON.parse(text); } catch(e){ throw new Error(`Respuesta no JSON: ${text.slice(0,200)}`); }
    if(!resp.ok || json.error){ throw new Error(`HTTP ${resp.status} · ${json.error || text}`); }
    uploadLog.textContent = `OK: ${json.fileUrl || 'guardado'}`;
    return;
  }catch(e){
    console.warn('Multipart falló, probamos JSON base64:', e);
  }

  // ---- Intento 2: JSON base64 (DataURL) ----
  try{
    const dataURL = await new Promise((res, rej) => {
      const r = new FileReader();
      r.onload = () => res(r.result);
      r.onerror = rej;
      r.readAsDataURL(blob);   // "data:image/jpeg;base64,AAAA..."
    });

    const payload = {
      filename: fname,
      name: nameInput.value.trim() || 'anon',
      folder: DRIVE_FOLDER,
      folderId: DRIVE_FOLDER_ID,
      secret: DRIVE_SECRET,
      image: dataURL
    };

    const resp = await fetch(DRIVE_WEBAPP_URL, {
      method:'POST',
      headers:{ 'Content-Type':'application/json' },
      body: JSON.stringify(payload)
    });
    const text = await resp.text();
    let json; try { json = JSON.parse(text); } catch(e){ throw new Error(`Respuesta no JSON: ${text.slice(0,200)}`); }
    if(!resp.ok || json.error){ throw new Error(`HTTP ${resp.status} · ${json.error || text}`); }
    uploadLog.textContent = `OK: ${json.fileUrl || 'guardado'}`;
  }catch(e2){
    uploadLog.textContent = 'Error al subir: ' + e2.message;
    console.error('Upload error:', e2);
    alert('Error al subir: ' + e2.message);
  }
}

captureBtn.addEventListener('click', async ()=>{
  if(!track || track.stable<STABILITY.requireStableFrames){ alert('Mantén el ojo estable unos instantes hasta que el recuadro quede fijo.'); return; }
  const blob = await cropToBlob({xyxy: track.box});
  thumb.src = URL.createObjectURL(blob);
  await uploadToDrive(blob);
});
</script>
</body>
</html>
